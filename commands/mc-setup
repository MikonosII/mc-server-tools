#!/usr/bin/env bash
set -euo pipefail

. /usr/share/mc-server-tools/lib/common.sh
require_root
# Load networking config (create defaults if missing)
CONFIG_FILE="/etc/mc-server-tools/config"
if [[ ! -f "$CONFIG_FILE" ]]; then
  install -d -m 0755 /etc/mc-server-tools
  cat >"$CONFIG_FILE" <<'EOF'
BRIDGE="vmbr0"
NET_JAVA_START="192.168.205.100"
NET_JAVA_PREFIX="24"
NET_JAVA_GW="auto"
NET_BEDROCK_START="192.168.206.100"
NET_BEDROCK_PREFIX="24"
NET_BEDROCK_GW="auto"
DEFAULT_TEMPLATE=""
EOF
fi
# shellcheck disable=SC1090
. "$CONFIG_FILE"

# Default disk size in GiB for pct create (integer, no G suffix)
: "${DISK_GB:=16}"

# ----- IP math helpers -----
ip_to_int() { # $1=IPv4
  awk -v ip="$1" 'BEGIN{split(ip,a,"."); print (a[1]*16777216 + a[2]*65536 + a[3]*256 + a[4]) }'
}
int_to_ip() { # $1=int
  awk -v n="$1" 'BEGIN{a=int(n/16777216);n-=a*16777216;b=int(n/65536);n-=b*65536;c=int(n/256);n-=c*256;d=n; printf("%d.%d.%d.%d",a,b,c,d)}'
}
mask_from_prefix() { # $1=prefix -> int mask
  awk -v p="$1" 'BEGIN{m=(2^32-1)-(2^(32-p)-1); print m}'
}
network_of() { # $1=ip $2=prefix -> network ip
  awk -v ip="$1" -v p="$2" 'BEGIN{
    split(ip,a,"."); ipi=a[1]*16777216+a[2]*65536+a[3]*256+a[4];
    m=(2^32-1)-(2^(32-p)-1);
    n=and(ipi,m);
    printf("%d.%d.%d.%d", int(n/16777216)%256, int(n/65536)%256, int(n/256)%256, n%256)
  }'
}
first_host() { # $1=ip $2=prefix -> network+1
  awk -v ip="$1" -v p="$2" 'BEGIN{
    split(ip,a,"."); ipi=a[1]*16777216+a[2]*65536+a[3]*256+a[4];
    m=(2^32-1)-(2^(32-p)-1);
    n=and(ipi,m)+1;
    printf("%d.%d.%d.%d", int(n/16777216)%256, int(n/65536)%256, int(n/256)%256, n%256)
  }'
}
broadcast_of() { # $1=ip $2=prefix -> broadcast ip
  awk -v ip="$1" -v p="$2" 'BEGIN{
    split(ip,a,"."); ipi=a[1]*16777216+a[2]*65536+a[3]*256+a[4];
    m=(2^32-1)-(2^(32-p)-1);
    b=or(and(ipi,m),(2^(32-p)-1));
    printf("%d.%d.%d.%d", int(b/16777216)%256, int(b/65536)%256, int(b/256)%256, b%256)
  }'
}

ip_in_same_subnet() { # $1=ip $2=seed $3=prefix
  local net1 net2; net1=$(network_of "$1" "$3"); net2=$(network_of "$2" "$3")
  [[ "$net1" == "$net2" ]]
}

# Extract ip= value from a CT's net0, if present
ct_ip() {
  local id=$1
  pct config "$id" 2>/dev/null | awk -F'[=, ]' '/^net0:/{for(i=1;i<=NF;i++) if($i=="ip"){print $(i+1)}}'
}

# Is IP already in use by any LXC config we manage?
ip_used_by_cts() {
  local ip=$1
  while read -r id _; do
    [[ "$id" =~ ^[0-9]+$ ]] || continue
    local nip; nip=$(ct_ip "$id")
    [[ "$nip" == "$ip"/* ]] && return 0
  done < <(pct list | awk 'NR>1{print $1}')
  return 1
}

# Next free host IP starting from SEED in that subnet (skips network & broadcast)
next_free_ip() { # $1=seed_ip $2=prefix
  local seed=$1 pfx=$2
  local net=$(network_of "$seed" "$pfx")
  local bcast=$(broadcast_of "$seed" "$pfx")
  local cur_int=$(( $(ip_to_int "$seed") ))
  local bcast_int=$(( $(ip_to_int "$bcast") ))
  # ensure start >= first host
  local first=$(first_host "$seed" "$pfx")
  local first_int=$(( $(ip_to_int "$first") ))
  (( cur_int < first_int )) && cur_int=$first_int

  while (( cur_int < bcast_int )); do
    local candidate=$(int_to_ip "$cur_int")
    if ! ip_used_by_cts "$candidate"; then
      echo "$candidate"; return 0
    fi
    ((cur_int++))
  done
  return 1
}

# Template persistence & discovery
installed_templates() {
  # Discover installed LXC templates by scanning storage cache paths.
  # Output format: <storage>:vztmpl/<file>
  local s path
  while read -r s; do
    if [[ "$s" == "local" ]]; then
      path=/var/lib/vz/template/cache
    else
      path=/mnt/pve/"$s"/template/cache
    fi
    if [[ -d "$path" ]]; then
      find "$path" -maxdepth 1 -type f -printf '%f
' 2>/dev/null | while read -r f; do
        printf '%s:vztmpl/%s
' "$s" "$f"
      done
    fi
  done < <(pvesm status 2>/dev/null | awk 'NR>1{print $1}')
}

# Return the on-disk cache path for a storage name
_template_cache_path_for_storage() {
  local s="$1"
  if [[ "$s" == "local" ]]; then
    echo /var/lib/vz/template/cache
  else
    echo "/mnt/pve/$s/template/cache"
  fi
}

# Check if a fully-qualified template (storage:vztmpl/file) is installed
_template_exists() {
  local sel="$1"
  [[ "$sel" == *":vztmpl/"* ]] || return 1
  local storage file
  storage="${sel%%:vztmpl/*}"
  file="${sel##*:vztmpl/}"
  local path; path=$(_template_cache_path_for_storage "$storage")
  [[ -f "$path/$file" ]]
}

# List storages that can hold templates (all storages known to PVE)
_dir_storages() {
  pvesm status 2>/dev/null | awk 'NR>1{print $1}'
}

# List catalog templates available to download (names only)
_available_templates_catalog() {
  pveam available --section system 2>/dev/null | awk 'NR>1 && $2!="" {print $2}'
}

# Prompt for a storage (defaults to 'local' if present)
_choose_storage() {
  local -a arr; mapfile -t arr < <(_dir_storages)
  ((${#arr[@]})) || { err "No storages found via pvesm status"; return 1; }
  local def_idx=1
  local i
  for i in "${!arr[@]}"; do [[ "${arr[$i]}" == "local" ]] && def_idx=$((i+1)); done
  {
    echo "Storages:"; for i in "${!arr[@]}"; do printf '  %d) %s
' "$((i+1))" "${arr[$i]}"; done; echo; 
  } >&2
  local choice
  read -r -p "Choose storage for download [${def_idx}]: " choice
  if [[ -z "$choice" ]]; then echo "${arr[$((def_idx-1))]}"; return; fi
  if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#arr[@]} )); then echo "${arr[$((choice-1))]}"; return; fi
  echo "$choice"
}

# Download flow: pick storage & template name from catalog, download, return fully-qualified path
_download_template_dialog() {
  local storage name
  storage=$(_choose_storage) || return 1
  local -a cats; mapfile -t cats < <(_available_templates_catalog)
  ((${#cats[@]})) || { err "No catalog entries from pveam available"; return 1; }
  {
    echo "Available templates:"; 
    local show=$(( ${#cats[@]}<20 ? ${#cats[@]} : 20 ))
    local i; for ((i=0;i<show;i++)); do printf '  %d) %s
' "$((i+1))" "${cats[$i]}"; done; echo;
  } >&2
  local choice
  read -r -p "Download which? (number or full name) [1]: " choice
  if [[ -z "$choice" ]]; then name="${cats[0]}"; 
  elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#cats[@]} )); then name="${cats[$((choice-1))]}"; 
  else name="$choice"; fi
  info "Downloading $name to $storage..."
  pveam download "$storage" "$name"
  echo "$storage:vztmpl/$name"
}

select_template() {
  local -a arr; mapfile -t arr < <(installed_templates)

  if (( ${#arr[@]} == 0 )); then
    { echo "No installed templates found."; } >&2
    local ans
    read -r -p "Download a template now? [Y/n]: " ans
    ans=${ans:-Y}
    if [[ "$ans" =~ ^[Yy]$ ]]; then
      local sel; sel=$(_download_template_dialog) || { err "Download failed"; exit 1; }
      set_config_var DEFAULT_TEMPLATE "$sel"
      echo "$sel"; return
    else
      err "Aborting: no templates installed."; exit 1
    fi
  fi

  { echo "Installed templates:"; local i; for i in "${!arr[@]}"; do printf '  %d) %s
' "$((i+1))" "${arr[$i]}"; done; echo; } >&2

  # Determine default index ONLY if DEFAULT_TEMPLATE exists and matches
  local def_idx=""
  if [[ -n "${DEFAULT_TEMPLATE:-}" ]]; then
    local idx; for idx in "${!arr[@]}"; do [[ "${arr[$idx]}" == "$DEFAULT_TEMPLATE" ]] && { def_idx=$((idx+1)); break; }; done
  fi

  # Build prompt: require explicit selection if no default
  local prompt
  if [[ -n "$def_idx" ]]; then
    prompt="Choose template [${def_idx}] or 'd' to download: "
  else
    prompt="Choose template (number) or 'd' to download: "
  fi

  local choice raw sel
  while :; do
    read -r -p "$prompt" choice
    if [[ -z "$choice" ]]; then
      if [[ -n "$def_idx" ]]; then
        sel="${arr[$((def_idx-1))]}"; break
      else
        echo "Please enter a number or 'd' to download." >&2; continue
      fi
    elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#arr[@]} )); then
      sel="${arr[$((choice-1))]}"; break
    elif [[ "$choice" =~ ^[dD]$ ]]; then
      sel=$(_download_template_dialog) || { err "Download failed"; exit 1; }; break
    else
      raw=$choice
      if [[ "$raw" == *":vztmpl/"* ]]; then
        if _template_exists "$raw"; then sel="$raw"; break; else echo "Template '$raw' not installed." >&2; continue; fi
      else
        # Match by filename across installed set
        local -a matches; matches=()
        local it
        for it in "${arr[@]}"; do [[ "${it##*:vztmpl/}" == "$raw" ]] && matches+=("$it"); done
        if (( ${#matches[@]} == 1 )); then sel="${matches[0]}"; break
        elif (( ${#matches[@]} > 1 )); then echo "Filename '$raw' is ambiguous; please select by number." >&2; continue
        else echo "Filename '$raw' not found; select a number or 'd' to download." >&2; continue
        fi
      fi
    fi
  done

  sel=$(printf '%s' "$sel" | tr -d '
' | awk '{sub(/[ 	]+$/,""); print}')
  set_config_var DEFAULT_TEMPLATE "$sel"
  echo "$sel"
}

set_config_var() { # $1=KEY $2=VALUE
  local key="$1" val="$2"
  if grep -q "^${key}=" "$CONFIG_FILE" 2>/dev/null; then
    sed -i "s#^${key}=.*#${key}=\"${val//\//\/}\"#" "$CONFIG_FILE"
  else
    printf '%s="%s"
' "$key" "$val" >> "$CONFIG_FILE"
  fi
}

# Optional non-interactive flags for automation
EDITION=""; VERSION=""; HN=""; MEM=""; CORES=""; BKT=""; CTID_IN=""; PORT_IN=""; TEMPLATE_IN=""
while [[ ${1:-} == --* ]]; do
  case "$1" in
    --edition)       EDITION=${2:?}; shift 2;;
    --version)       VERSION=${2:?}; shift 2;;
    --hostname)      HN=${2:?}; shift 2;;
    --mem)           MEM=${2:?}; shift 2;;
    --cores)         CORES=${2:?}; shift 2;;
    --backup-hhmm)   BKT=${2:?}; shift 2;;
    --ctid)          CTID_IN=${2:?}; shift 2;;
    --port)          PORT_IN=${2:?}; shift 2;;
    --template)      TEMPLATE_IN=${2:?}; shift 2;;
    --) shift; break;;
    *) err "Unknown flag: $1"; exit 1;;
  esac
done

# ----- Static IPv4 assignment (no DHCP) -----
if [[ "$EDITION" == "Java" ]]; then
  IPV4_SEED="${NET_JAVA_START}"
  IPV4_PFX="${NET_JAVA_PREFIX:-24}"
  if [[ "${NET_JAVA_GW:-auto}" == "auto" || -z "${NET_JAVA_GW:-}" ]]; then
    IPV4_GW="$(first_host "$IPV4_SEED" "$IPV4_PFX")"
    # common case: force .1 if /24 and seed not .1 subnet
    [[ "$IPV4_PFX" == "24" ]] && IPV4_GW="$(echo "$IPV4_SEED" | awk -F. '{printf "%d.%d.%d.1",$1,$2,$3}')"
  else
    IPV4_GW="$NET_JAVA_GW"
  fi
else
  IPV4_SEED="${NET_BEDROCK_START}"
  IPV4_PFX="${NET_BEDROCK_PREFIX:-24}"
  if [[ "${NET_BEDROCK_GW:-auto}" == "auto" || -z "${NET_BEDROCK_GW:-}" ]]; then
    IPV4_GW="$(first_host "$IPV4_SEED" "$IPV4_PFX")"
    [[ "$IPV4_PFX" == "24" ]] && IPV4_GW="$(echo "$IPV4_SEED" | awk -F. '{printf "%d.%d.%d.1",$1,$2,$3}')"
  else
    IPV4_GW="$NET_BEDROCK_GW"
  fi
fi

IPV4_ADDR="$(next_free_ip "$IPV4_SEED" "$IPV4_PFX")" || {
  err "No free IPs available in $(network_of "$IPV4_SEED" "$IPV4_PFX")/$IPV4_PFX"
}


echo "=== Minecraft Server Setup ==="

# --- helpers ---
ctid_exists() { pct config "$1" >/dev/null 2>&1; }
port_in_use_host() { ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":$1$"; }
seed_port() { [[ ${1:-Java} == Bedrock ]] && echo 19132 || echo 25565; }

next_free_ctid_port() {
  local start=$1
  local p=$start
  while :; do
    if ! ctid_exists "$p" && ! port_in_use_host "$p"; then
      echo "$p"; return 0
    fi
    p=$((p+1))
    (( p <= 65535 )) || { err "No free CTID/port found above $start"; return 1; }
  done
}

select_template() {
  local -a arr; mapfile -t arr < <(installed_templates)
  if (( ${#arr[@]} == 0 )); then
    err "No installed templates found. Use 'pveam download local <name>' first."; exit 1
  fi

  # Print menu to STDERR so command substitution doesn't capture it
  {
    echo "Installed templates:"
    local i
    for i in "${!arr[@]}"; do
      printf '  %d) %s
' "$((i+1))" "${arr[$i]}"
    done
    echo
  } >&2

  # Default from config if present and matches; otherwise first entry
  local def_idx=1
  if [[ -n "${DEFAULT_TEMPLATE:-}" ]]; then
    local idx
    for idx in "${!arr[@]}"; do
      if [[ "${arr[$idx]}" == "$DEFAULT_TEMPLATE" ]]; then def_idx=$((idx+1)); break; fi
    done
  fi

  local choice sel
  # read -p prints prompt to STDERR by default (safe for command substitution)
  read -r -p "Choose template [${def_idx}]: " choice
  if [[ -z "$choice" ]]; then
    sel="${arr[$((def_idx-1))]}"
  elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#arr[@]} )); then
    sel="${arr[$((choice-1))]}"
  else
    # allow fully qualified storage:vztmpl/file entry
    sel="$choice"
  fi

  # Sanitize selection (strip CR/trailing spaces)
  sel=$(printf '%s' "$sel" | tr -d '
' | awk '{sub(/[ 	]+$/,""); print}')

  # Persist and return ONLY the selection on STDOUT
  set_config_var DEFAULT_TEMPLATE "$sel"
  echo "$sel"
}

# Edition
if [[ -z "$EDITION" ]]; then
  read -r -p "Server Edition [Java]: " EDITION
  EDITION=${EDITION:-Java}
fi
if [[ $EDITION != "Java" && $EDITION != "Bedrock" ]]; then
  err "Edition must be 'Java' or 'Bedrock'"; exit 1
fi

# Version
if [[ -z "$VERSION" ]]; then
  read -r -p "Minecraft Version [Latest]: " VERSION
  VERSION=${VERSION:-Latest}
fi

# Memory
if [[ -z "$MEM" ]]; then
  read -r -p "Memory (MB) [4096]: " MEM
  MEM=${MEM:-4096}
fi
[[ "$MEM" =~ ^[0-9]+$ ]] || { err "Memory must be numeric (MB)"; exit 1; }

# Cores
if [[ -z "$CORES" ]]; then
  read -r -p "CPU cores [2]: " CORES
  CORES=${CORES:-2}
fi
[[ "$CORES" =~ ^[0-9]+$ ]] || { err "Cores must be numeric"; exit 1; }

# Backup HHMM
if [[ -z "$BKT" ]]; then
  while true; do
    read -r -p "Daily backup time (HHMM, 24h) [0400]: " BKT
    BKT=${BKT:-0400}
    if validate_hhmm "$BKT"; then break; else warn "Invalid HHMM. Try again."; fi
  done
else
  validate_hhmm "$BKT" || { err "Invalid --backup-hhmm (use HHMM)"; exit 1; }
fi

# --- Auto CTID/Port selection (CTID=Port enforced) ---
if [[ -n "$CTID_IN" || -n "$PORT_IN" ]]; then
  [[ -z "$CTID_IN" ]] && CTID_IN=$PORT_IN
  [[ -z "$PORT_IN" ]] && PORT_IN=$CTID_IN
  [[ "$CTID_IN" == "$PORT_IN" ]] || { err "CTID and Port must match (CTID=Port policy)."; exit 1; }
  [[ "$CTID_IN" =~ ^[0-9]+$ ]] || { err "CTID/Port must be numeric"; exit 1; }
  (( CTID_IN >= 1 && CTID_IN <= 65535 )) || { err "CTID/Port must be 1-65535"; exit 1; }
  ctid_exists "$CTID_IN" && { err "CTID $CTID_IN already exists"; exit 1; }
  port_in_use_host "$PORT_IN" && { err "Port $PORT_IN is in use on host"; exit 1; }
  CTID=$CTID_IN; PORT=$PORT_IN
else
  SEED=$(seed_port "$EDITION")
  PICK=$(next_free_ctid_port "$SEED")
  CTID=$PICK; PORT=$PICK
fi

# Hostname (default ties to CTID/Port)
if [[ -z "$HN" ]]; then
  read -r -p "Hostname [mc-$CTID]: " HN
  HN=${HN:-mc-$CTID}
fi

# Template selection with validation + download option
if [[ -n "$TEMPLATE_IN" ]]; then
  # Accept fully-qualified storage:vztmpl/file directly if installed
  if _template_exists "$TEMPLATE_IN"; then
    TEMPLATE="$TEMPLATE_IN"
  else
    # If only a filename was provided, try to resolve to an installed template
    if [[ "$TEMPLATE_IN" != *":vztmpl/"* ]]; then
      mapfile -t _arr_inst < <(installed_templates)
      _match=()
      for it in "${_arr_inst[@]}"; do [[ "${it##*:vztmpl/}" == "$TEMPLATE_IN" ]] && _match+=("$it"); done
      if (( ${#_match[@]} == 1 )); then
        TEMPLATE="${_match[0]}"
      else
        info "Template '$TEMPLATE_IN' not installed or ambiguous. Launching downloader..."
        TEMPLATE=$(_download_template_dialog) || { err "Download failed"; exit 1; }
      fi
    else
      info "Template '$TEMPLATE_IN' not installed. Launching downloader..."
      TEMPLATE=$(_download_template_dialog) || { err "Download failed"; exit 1; }
    fi
  fi
  set_config_var DEFAULT_TEMPLATE "$TEMPLATE"
else
  TEMPLATE=$(select_template)
fi

info "Summary"
echo "CTID:      $CTID"
echo "Hostname:  $HN"
echo "Edition:   $EDITION"
echo "Version:   $VERSION"
echo "Memory:    ${MEM}MB"
echo "Cores:     $CORES"
echo "IPv4:      ${IPV4_ADDR}/${IPV4_PFX}  gw ${IPV4_GW}"
echo "Port:      $PORT"
echo "Template:  $TEMPLATE"
echo "Autostart: Yes (always)"
echo "Backups:   Daily @ ${BKT:0:2}:${BKT:2:2}"

# --- Create LXC using selected template ---
STOR=$(pvesh get /storage 2>/dev/null | awk '/local-lvm/{print $2}' | head -n1)
STOR=${STOR:-local}

info "Creating container CT $CTID..."
pct create "$CTID" "$TEMPLATE" \
  -hostname "$HN" \
  -cores "$CORES" \
  -memory "$MEM" \
  -swap 0 \
  -net0 "name=eth0,bridge=${BRIDGE},ip=${IPV4_ADDR}/${IPV4_PFX},gw=${IPV4_GW}" \
  -rootfs "$STOR:${DISK_GB}" \
  -unprivileged 1 \
  -onboot 1

info "Starting CT $CTID..."; pct start "$CTID"

if [[ $EDITION == "Java" ]]; then
  info "Installing Java (official Mojang vanilla) and server jar (as mcadmin)..."
pct exec "$CTID" -- env MC_VER="$VERSION" bash -lc '
  set -e
  apt-get update
  apt-get install -y openjdk-21-jre-headless curl jq screen
  id -u mcadmin >/dev/null 2>&1 || useradd -m -s /bin/bash mcadmin
  install -d -o mcadmin -g mcadmin /opt/minecraft
  cd /opt/minecraft
  VER="${MC_VER:-Latest}"
  # Resolve requested version to an official server JAR URL
  if [[ "$VER" == "Latest" || "$VER" == "latest" ]]; then
    VER=$(curl -fsSL https://launchermeta.mojang.com/mc/game/version_manifest.json | jq -r '.latest.release')
  fi
  MANIFEST_URL=$(curl -fsSL https://launchermeta.mojang.com/mc/game/version_manifest.json | jq -r --arg v "$VER" '.versions[] | select(.id==$v) | .url' | head -n1)
  if [[ -z "$MANIFEST_URL" || "$MANIFEST_URL" == "null" ]]; then
    echo "Requested version $VER not found; falling back to latest release" >&2
    VER=$(curl -fsSL https://launchermeta.mojang.com/mc/game/version_manifest.json | jq -r '.latest.release')
    MANIFEST_URL=$(curl -fsSL https://launchermeta.mojang.com/mc/game/version_manifest.json | jq -r --arg v "$VER" '.versions[] | select(.id==$v) | .url' | head -n1)
  fi
  JAR_URL=$(curl -fsSL "$MANIFEST_URL" | jq -r '.downloads.server.url')
  curl -fSL -o server.jar "$JAR_URL"
  echo "eula=true" > eula.txt
  chown -R mcadmin:mcadmin /opt/minecraft
'

info "Creating start script and service (runs as mcadmin)..."
  pct exec "$CTID" -- bash -lc "cat >/usr/local/bin/mc-start << 'EOS'
#!/usr/bin/env bash
set -e
cd /opt/minecraft
# keep session name \"mc\" for compatibility with tooling
su -s /bin/bash - mcadmin -c \"screen -dmS mc java -Xms512M -Xmx${MEM}M -jar server.jar nogui\"
EOS
chmod +x /usr/local/bin/mc-start"

  pct exec "$CTID" -- bash -lc 'cat >/etc/systemd/system/minecraft.service << "EOF"
[Unit]
Description=Minecraft Server (Vanilla)
After=network.target

[Service]
Type=forking
User=root
ExecStart=/usr/local/bin/mc-start
ExecStop=/usr/bin/screen -S mc -p 0 -X stuff "stop^M"
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF'

  pct exec "$CTID" -- systemctl enable minecraft.service

else
  info "Setting up Bedrock (as mcadmin; beta minimal)"
  pct exec "$CTID" -- bash -lc '
    set -e
    apt-get update
    apt-get install -y unzip curl screen
    id -u mcadmin >/dev/null 2>&1 || useradd -m -s /bin/bash mcadmin
    install -d -o mcadmin -g mcadmin /opt/bedrock
    cd /opt/bedrock
    # Find the official direct ZIP link from the download page
BEDROCK_URL=$(curl -fsSL https://www.minecraft.net/en-us/download/server/bedrock \
  | grep -oE "https://minecraft\.azureedge\.net/bin-linux/bedrock-server-[0-9\.]+\.zip" \
  | head -n1)
if [[ -z "$BEDROCK_URL" ]]; then
  echo "Failed to detect Bedrock server URL" >&2; exit 1
fi
curl -fsSL -o bedrock-server.zip "$BEDROCK_URL"
    unzip -o bedrock-server.zip
    chown -R mcadmin:mcadmin /opt/bedrock
  '
  # TODO: create a systemd service similar to Java that starts Bedrock as mcadmin
fi

# --- Backups via host cron (vzdump) ---
H=${BKT:0:2}; M=${BKT:2:2}
CRONFILE="/etc/cron.d/mc-server-${CTID}"
echo "$M $H * * * root /usr/bin/mc backup $CTID" > "$CRONFILE"
chmod 0644 "$CRONFILE"

info "Done! Use: mc start $CTID | mc logs $CTID | mc console $CTID | mc backup $CTID | mc list"
